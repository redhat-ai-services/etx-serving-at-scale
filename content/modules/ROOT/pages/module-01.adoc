= Model as a Service (MaaS)

High Level Architecture of MaaS to move to capability focus instead of product focus

image::MaaS.png[]

== 3scale and RHCL Current Capabilities (Noel)

== Checklist of Capabilities (Kenny)

== Pattern Assumptions (kenny)

== Existing Slides +
. https://docs.google.com/presentation/d/1R38W2ZuRo7zsX58airHsbstOO7UCVc5iRbAV7T1DYgA/edit?usp=sharing[^]

== Existing lab resources

. RH AI BU MaaS repo +
https://github.com/rh-aiservices-bu/models-aas[^]

. MaaS Workshop +
https://catalog.demo.redhat.com/catalog?item=babylon-catalog-event/summit-2025.lb1816-llmaas.event&utm_source=webapp&utm_medium=share-link[^]

. Roadshow with MaaS +
https://github.com/odh-labs/rhoai-roadshow-v2[^]

. MaaS automation +
https://github.com/redhat-gpte-devopsautomation/lb1816-summit-llm-aas[^]

== Potential Topics to Cover in the Lab

[#api_gateway]
=== API Gateway

* APISix
* 3scale
* LiteLLM

[#auth]
=== Authorization

* Keycloak
* Customer provided

== Keycloak and 3Scale

Use Keycloak to authenticate users and then obtain a token to use with Red Hat 3scale API Management. This is a common architecture where Keycloak handles identity and access management (IAM), while 3scale handles API rate limiting, analytics, and monetization.

Here's a high-level outline of how to set it up:

✅ Architecture Overview
Client authenticates via Keycloak
Receives an OAuth2 access token (JWT)
Uses that token to call an API protected by 3scale
3scale validates the token via a policy (e.g., OIDC, custom LUA)

🛠️ Setup Steps
1. Configure Keycloak as Identity Provider
Create a Realm and a Client in Keycloak
Set the Client to use confidential or public access type depending on your scenario
Enable standard flow (OAuth2 Authorization Code) or client credentials flow

2. Enable OpenID Connect (OIDC) Integration in 3scale
Option A: OIDC External Integration (Recommended)
In 3scale Admin Portal:
Go to Integration > Settings
Select OpenID Connect as authentication method
Provide Keycloak’s OIDC Discovery URL (e.g., https://<keycloak-host>/realms/<realm-name>/.well-known/openid-configuration)
Map scopes/claims if needed
3scale will now:
Validate the JWT token
Forward the request to the backend if valid

3. Use the Token in API Calls
After login, the client will receive a JWT access token from Keycloak. You can call 3scale-protected APIs like this:
GET /your/api/endpoint HTTP/1.1
Authorization: Bearer <keycloak-jwt-token>

Rate Limiting by Client
You can:
Use Keycloak client_id or user_id from token to uniquely identify users
Map these to 3scale Application Plans for rate limits and quotas

✅ Benefits of This Setup
Decouples auth (Keycloak) from API management (3scale)
Centralizes IAM
Uses standards-based security (OAuth2, OIDC, JWT)
Easy to federate with other IdPs (AD, Google, etc.) via Keycloak

